/*
 * Copyright 2024, the wasi-emscripten-host project authors and contributors. Please see the AUTHORS file
 * for details. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 * SPDX-License-Identifier: Apache-2.0
 */

package at.released.weh.filesystem.linux

import assertk.all
import assertk.assertThat
import assertk.assertions.isEqualTo
import assertk.assertions.isNotNull
import at.released.weh.filesystem.linux.fdresource.LinuxFileSystemState
import at.released.weh.filesystem.model.BaseDirectory
import at.released.weh.filesystem.model.FileSystemErrno
import at.released.weh.filesystem.op.opencreate.Open
import at.released.weh.filesystem.op.opencreate.OpenFileFlag
import at.released.weh.filesystem.test.fixtures.stdio.TestStandardInputOutput
import at.released.weh.filesystem.test.fixtures.toVirtualPath
import at.released.weh.test.filesystem.assertions.isEmpty
import at.released.weh.test.filesystem.assertions.isRegularFile
import at.released.weh.test.filesystem.assertions.mode.PosixFileModeBit.USER_EXECUTE
import at.released.weh.test.filesystem.assertions.mode.PosixFileModeBit.USER_READ
import at.released.weh.test.filesystem.assertions.mode.PosixFileModeBit.USER_WRITE
import at.released.weh.test.filesystem.assertions.mode.posixFileModeIfSupportedIsEqualTo
import at.released.weh.test.utils.TempFolder
import at.released.weh.test.utils.absolutePath
import kotlinx.io.files.Path
import platform.posix.close
import kotlin.test.AfterTest
import kotlin.test.BeforeTest
import kotlin.test.Test

class LinuxOpenTest {
    lateinit var tempFolder: TempFolder

    @BeforeTest
    fun setup() {
        tempFolder = TempFolder.create()
    }

    @AfterTest
    fun cleanup() {
        tempFolder.delete()
    }

    @Test
    fun create_file_with_relative_path_should_work() {
        val fsState = LinuxFileSystemState.create(
            stdio = TestStandardInputOutput(),
            isRootAccessAllowed = false,
            currentWorkingDirectory = tempFolder.path,
            preopenedDirectories = listOf(),
        )
        val linuxOpen = LinuxOpen(fsState)

        val tempFileAbsolutePath = tempFolder.absolutePath()
        val testFile = "file.test"

        val request = Open(
            path = testFile.toVirtualPath(),
            baseDirectory = BaseDirectory.CurrentWorkingDirectory,
            openFlags = OpenFileFlag.O_CREAT or OpenFileFlag.O_WRONLY,
            fdFlags = 0,
            mode = 0b111_000_000,
        )

        val newFd = linuxOpen.invoke(request).getOrNull()?.let {
            close(it)
        }

        assertThat(newFd).isNotNull()

        val testFileAbsolutePath = Path(tempFileAbsolutePath, testFile)
        assertThat(testFileAbsolutePath).all {
            isRegularFile()
            isEmpty()
            posixFileModeIfSupportedIsEqualTo(USER_READ, USER_WRITE, USER_EXECUTE)
        }
    }

    @Test
    fun create_file_with_absolute_path_should_not_work_if_root_access_not_allowed() {
        val fsState = LinuxFileSystemState.create(
            stdio = TestStandardInputOutput(),
            isRootAccessAllowed = false,
            currentWorkingDirectory = tempFolder.path,
            preopenedDirectories = listOf(),
        )
        val linuxOpen = LinuxOpen(fsState)

        val tempFileAbsolutePath = tempFolder.absolutePath()
        val testFile = Path(tempFileAbsolutePath, "file.test")

        val request = Open(
            path = testFile.toString().toVirtualPath(),
            baseDirectory = BaseDirectory.CurrentWorkingDirectory,
            openFlags = OpenFileFlag.O_CREAT or OpenFileFlag.O_WRONLY,
            fdFlags = 0,
            mode = 0b111_000_000,
        )

        val errorCode = linuxOpen.invoke(request)
            .fold(
                ifLeft = { it.errno },
                ifRight = {
                    close(it)
                    FileSystemErrno.SUCCESS
                },
            )

        assertThat(errorCode).isEqualTo(FileSystemErrno.NOTCAPABLE)
    }

    @Test
    fun create_file_with_absolute_path_should_work_if_root_access_is_allowed() {
        val fsState = LinuxFileSystemState.create(
            stdio = TestStandardInputOutput(),
            isRootAccessAllowed = true,
            currentWorkingDirectory = tempFolder.path,
            preopenedDirectories = listOf(),
        )
        val linuxOpen = LinuxOpen(fsState)

        val tempFileAbsolutePath = tempFolder.absolutePath()
        val testFile = Path(tempFileAbsolutePath, "file.test")

        val request = Open(
            path = testFile.toString().toVirtualPath(),
            baseDirectory = BaseDirectory.CurrentWorkingDirectory,
            openFlags = OpenFileFlag.O_CREAT or OpenFileFlag.O_WRONLY,
            fdFlags = 0,
            mode = 0b111_000_000,
        )

        val newFd = linuxOpen.invoke(request).getOrNull()?.let {
            close(it)
        }

        assertThat(newFd).isNotNull()

        assertThat(testFile).all {
            isRegularFile()
            isEmpty()
            posixFileModeIfSupportedIsEqualTo(USER_READ, USER_WRITE, USER_EXECUTE)
        }
    }
}
